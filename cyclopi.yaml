esphome:
  name: "cyclopi"
  friendly_name: "CycloPi"
  comment: "CycloPi Omnilight"
  platformio_options:
    board_build.flash_mode: dio  # FIXME: May not be necessary
  libraries:
    - "Wire"
    - "SPI"
    - "SensorLib@0.2.1"  # Some change after v0.2.1 makes compiling fail
  on_boot:
    then:
      - script.execute: apply_light_state

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

external_components:
  - source: github://dala318/esphome-qmi8658

logger:

globals:
  - id: light_mode
    type: int
    initial_value: "2"  # 0 = off, 1 = solid, 2 = Backlight
  - id: light_brightness
    type: int
    restore_value: true
    initial_value: "128"  # full brightness 0-255
  - id: light_color_red
    type: int
    restore_value: true
    initial_value: "255"
  - id: light_color_green
    type: int
    restore_value: true
    initial_value: "0"
  - id: light_color_blue
    type: int
    restore_value: true
    initial_value: "0"
  - id: light_effect_id
    type: int
    restore_value: true
    initial_value: "0"
  - id: shake_enabled
    type: bool
    restore_value: true
    initial_value: "true"

script:
  - id: apply_light_state
    then:
      - lambda: |-
          if (id(light_mode) == 0) {
              id(backlight).turn_off().perform();
          } else if (id(light_mode) == 1) {
              id(backlight).turn_on().set_effect("Backlight").perform();
          } else if (id(light_mode) == 2) {
              id(backlight).turn_on()
                .set_effect("None")
                .set_rgb((float)1.0, 1.0, 1.0)
                .set_brightness((float)id(light_brightness)/255.0)
                .perform();
          } else if (id(light_mode) == 3) {
              auto effects = id(backlight).get_effects();
              int idx = id(light_effect_id);  // your global integer
              if (idx >= 0 && idx < effects.size()) {
                  id(backlight).turn_on()
                      .set_effect(idx)
                      .set_rgb((float)id(light_color_red)/255.0,
                              (float)id(light_color_green)/255.0,
                              (float)id(light_color_blue)/255.0)
                      .set_brightness((float)id(light_brightness)/255.0)
                      .perform();
              } else {
                  ESP_LOGW("light", "Invalid effect_id: %d", idx);
              }
          }
          id(update_ble_characteristics).execute();

  - id: update_ble_characteristics
    then:
      - lambda: |-
          // Light mode
          id(light_mode_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_mode)});
          id(light_mode_char).notify();

          // Brightness
          id(light_brightness_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_brightness)});
          id(light_brightness_char).notify();

          // Color
          id(light_color_char).set_value(std::vector<uint8_t>{
            (uint8_t)id(light_color_red),
            (uint8_t)id(light_color_green),
            (uint8_t)id(light_color_blue)
          });
          id(light_color_char).notify();

          // Current Effect
          id(light_current_effect_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_effect_id)});
          id(light_current_effect_char).notify();

          // Shake detection toggle
          id(shake_enable_char).set_value(std::vector<uint8_t>{ (uint8_t)(id(shake_enabled) ? 1 : 0) });
          id(shake_enable_char).notify();

esp32_ble_server:
  manufacturer: "CycloPi"
  model: "Omnilight"
  on_connect:
    then:
      - delay: 2s
      - script.execute: update_ble_characteristics
      - delay: 2s
      - script.execute: update_ble_characteristics
      - delay: 2s
      - script.execute: update_ble_characteristics
  services:
    - uuid: "12345678-1234-5678-1234-56789abcdef0"
      advertise: true
      characteristics:

        # Light mode characteristic
        - id: light_mode_char
          uuid: "abcdef01-1234-5678-1234-56789abcdef0"
          description: "Light Mode: 0=Off,1=Solid,2=Effect"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 0
          descriptors:
            - uuid: 2901
              value: "Set light mode: 0=Off,1=Solid,2=Effect"
          on_write:
            then:
              - lambda: |-
                  uint8_t mode = x[0];
                  ESP_LOGD("ble", "Light mode written: %d", mode);
                  id(light_mode) = mode;
              - script.execute: apply_light_state

        # Brightness characteristic
        - id: light_brightness_char
          uuid: "abcdef02-1234-5678-1234-56789abcdef0"
          description: "Brightness (0-255)"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 255
          descriptors:
            - uuid: 2901
              value: "Set brightness 0-255"
          on_write:
            then:
              - lambda: |-
                  uint8_t b = x[0];
                  id(light_brightness) = b;
                  ESP_LOGD("ble", "Brightness written: %d", id(light_brightness));
              - script.execute: apply_light_state

        # Color characteristic (RGB)
        - id: light_color_char
          uuid: "abcdef03-1234-5678-1234-56789abcdef0"
          description: "Effect Color RGB"
          read: true
          write: true
          notify: true
          value: "0xFF0000"  # red as default
          descriptors:
            - uuid: 2901
              value: "Set color: RGB bytes 0-255"
          on_write:
            then:
              - lambda: |-
                  uint8_t r = x[0];
                  uint8_t g = x[1];
                  uint8_t b = x[2];
                  id(light_color_red)   = r;
                  id(light_color_green) = g;
                  id(light_color_blue)  = b;
                  ESP_LOGD("ble", "Color written: R=%d G=%d B=%d", r, g, b);
              - script.execute: apply_light_state

        # Current Effect Name
        - id: light_current_effect_char
          uuid: "abcdef06-1234-5678-1234-56789abcdef0"
          description: "Current Light Effect Name"
          read: true
          write: true
          notify: true
          value: !lambda |-
            return std::vector<uint8_t>{(uint8_t)id(light_effect_id)};
          on_write:
            then:
              - lambda: |-
                  if (!x.empty()) {
                    id(light_effect_id) = x[0];
                    ESP_LOGD("ble", "Effect ID written: %d", id(light_effect_id));
                  }
              - script.execute: apply_light_state
          descriptors:
            - uuid: 2901
              value: "Current light effect"

        # Shake Detection Toggle
        - id: shake_enable_char
          uuid: "abcdef04-1234-5678-1234-56789abcdef0"
          description: "Enable/Disable Shake Detection (0=Off, 1=On)"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 1   # default enabled
          descriptors:
            - uuid: 2901
              value: "Toggle shake detection"
          on_write:
            then:
              - lambda: |-
                  bool enabled = x[0] != 0;
                  id(shake_enabled) = enabled;
                  ESP_LOGD("ble", "Shake detection written: %s", enabled ? "enabled" : "disabled");

        # Acceleration XYZ (3x float32 = 12 bytes)
        - id: accel_char
          uuid: "abcdef10-1234-5678-1234-56789abcdef0"
          description: "Acceleration X,Y,Z in m/s²"
          read: true
          notify: true

        # Gyroscope XYZ (3x float32 = 12 bytes)
        - id: gyro_char
          uuid: "abcdef11-1234-5678-1234-56789abcdef0"
          description: "Gyroscope X,Y,Z in °/s"
          read: true
          notify: true

        # IMU Temperature (float32 = 4 bytes)
        - id: temp_char
          uuid: "abcdef12-1234-5678-1234-56789abcdef0"
          description: "IMU Temperature in °C"
          read: true
          notify: true

interval:
  - interval: 1s
    then:
      # Update accel values (3 floats)
      - lambda: |-
          float ax = id(accel_x).state;
          float ay = id(accel_y).state;
          float az = id(accel_z).state;
          std::vector<uint8_t> accel_bytes(reinterpret_cast<uint8_t*>(&ax), reinterpret_cast<uint8_t*>(&ax) + sizeof(float));
          accel_bytes.insert(accel_bytes.end(), reinterpret_cast<uint8_t*>(&ay), reinterpret_cast<uint8_t*>(&ay) + sizeof(float));
          accel_bytes.insert(accel_bytes.end(), reinterpret_cast<uint8_t*>(&az), reinterpret_cast<uint8_t*>(&az) + sizeof(float));
          id(accel_char).set_value(accel_bytes);
          id(accel_char).notify();
      # Update gyro values (3 floats)
      - lambda: |-
          float gx = id(gyro_x).state;
          float gy = id(gyro_y).state;
          float gz = id(gyro_z).state;
          std::vector<uint8_t> gyro_bytes(reinterpret_cast<uint8_t*>(&gx), reinterpret_cast<uint8_t*>(&gx) + sizeof(float));
          gyro_bytes.insert(gyro_bytes.end(), reinterpret_cast<uint8_t*>(&gy), reinterpret_cast<uint8_t*>(&gy) + sizeof(float));
          gyro_bytes.insert(gyro_bytes.end(), reinterpret_cast<uint8_t*>(&gz), reinterpret_cast<uint8_t*>(&gz) + sizeof(float));
          id(gyro_char).set_value(gyro_bytes);
          id(gyro_char).notify();
      # Update temperature value (1 float)
      - lambda: |-
          float t = id(imu_temp).state;
          std::vector<uint8_t> temp_bytes(reinterpret_cast<uint8_t*>(&t), reinterpret_cast<uint8_t*>(&t) + sizeof(float));
          id(temp_char).set_value(temp_bytes);
          id(temp_char).notify();

  # Shake detection
  - interval: 50ms
    then:
      - lambda: |-
          if (!id(shake_enabled)) return;  // shake disabled

          static unsigned long last_trigger = 0;
          unsigned long now = millis();

          float ax = id(accel_x).state;
          float ay = id(accel_y).state;
          float az = id(accel_z).state;
          float magnitude = sqrt(ax*ax + ay*ay + az*az);

          const float threshold = 6;  // m/s²
          const unsigned long debounce = 500; // ms

          if (magnitude > threshold && now - last_trigger > debounce) {
            last_trigger = now;

            // increment light mode modulo 4 light modes
            id(light_mode) = (id(light_mode) + 1) % 4;

            ESP_LOGD("shake", "Shake detected, new light mode: %d", id(light_mode));

            // apply new light state via script
            id(apply_light_state).execute();
          }

  # Avoid over heating, reduce brightness
  - interval: 30s
    then:
      - lambda: |-
          // Read current temperature
          float temp = id(imu_temp).state;

          // Only reduce brightness if temp > 68
          if (temp > 68.0) {
            // Get current brightness (assuming you have a light entity)
            int current_brightness = id(light_brightness);

            // Reduce by ratio on a 0-255 scale
            float reduction = 20.0 * (temp - 68.0);
            int new_brightness = current_brightness - int(reduction);
            if (new_brightness < 32) new_brightness = 32;
            ESP_LOGD("brightness", "New brightness due to over temperature (%d -> %d, %d°C)", current_brightness, new_brightness, temp);

            // Set new brightness
            id(light_brightness) = new_brightness;
            id(apply_light_state).execute();
          }

light:
  - platform: esp32_rmt_led_strip
    rgb_order: RGB
    chipset: ws2811
    id: backlight
    pin: GPIO14
    num_leds: 64
    default_transition_length: 0.3s
    color_correct: [100%, 70%, 100%]
    effects:
      - flicker:
          name: "Flicker"
          intensity: 3%
      - addressable_rainbow:
          name: "Rainbow"
      - addressable_fireworks:
          name: "Fireworks"
      - pulse:
          name: "Pulse"
      - strobe:
          name: 'Backlight'
          colors:
            - state: true
              brightness: 100%
              red: 100%
              green: 0%
              blue: 0%
              duration: 300ms
            - state: true
              brightness: 100%
              red: 100%
              green: 75%
              blue: 0%
              duration: 50ms
            - state: false
              duration: 150ms

i2c:
  sda: GPIO11
  scl: GPIO12

sensor:
  - platform: qmi8658
    address: 0x6B
    interrupt_pin_2: GPIO13
    acceleration_x:
      id: accel_x
      name: "QMI8658 Acceleration X"
    acceleration_y:
      id: accel_y
      name: "QMI8658 Acceleration Y"
    acceleration_z:
      id: accel_z
      name: "QMI8658 Acceleration Z"
    gyroscope_x:
      id: gyro_x
      name: "QMI8658 Gyro X"
    gyroscope_y:
      id: gyro_y
      name: "QMI8658 Gyro Y"
    gyroscope_z:
      id: gyro_z
      name: "QMI8658 Gyro Z"
    temperature:
      id: imu_temp
      name: "QMI8658 Temperature"
      filters:
        - offset: 1.0
        - multiply: 0.75
    update_interval: 1s
