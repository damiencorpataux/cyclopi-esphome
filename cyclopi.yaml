esphome:
  name: "cyclopi"
  friendly_name: "CycloPi"
  comment: "CycloPi Omnilight"
  platformio_options:
    board_build.flash_mode: dio  # FIXME: May not be necessary
  libraries:
    - "Wire"
    - "SPI"
    - "SensorLib@0.2.1"  # Some change after v0.2.1 makes compiling fail
  on_boot:
    then:
      - script.execute: apply_light_state

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

preferences:
  flash_write_interval: never  # Preferences are manually saved via BLE save_prefs_char

external_components:
  - source: github://dala318/esphome-qmi8658

logger:

globals:
  - id: light_mode
    type: int
    restore_value: true
    initial_value: "2"  # 0 = off, 1 = solid, 2 = backlight, 3 = effect
  - id: light_brightness
    type: int
    restore_value: true
    initial_value: "128"  # full brightness 0-255
  - id: light_color_red
    type: int
    restore_value: true
    initial_value: "255"
  - id: light_color_green
    type: int
    restore_value: true
    initial_value: "0"
  - id: light_color_blue
    type: int
    restore_value: true
    initial_value: "0"
  - id: light_effect_id
    type: int
    restore_value: true
    initial_value: "0"
  - id: shake_enabled
    type: bool
    restore_value: true
    initial_value: "false"
  - id: overheat_protection_enabled
    type: bool
    restore_value: true
    initial_value: "true"

script:
  - id: apply_light_state
    then:
      - lambda: |-
          if (id(light_mode) == 0) {
              id(backlight).turn_off().perform();
          } else if (id(light_mode) == 1) {
              id(backlight).turn_on()
                .set_effect("Backlight")
                .set_brightness((float)id(light_brightness)/255.0)  // FIXME: Does not affect brightness
                .perform();
          } else if (id(light_mode) == 2) {
              id(backlight).turn_on()
                .set_effect("None")
                .set_rgb((float)1.0, 1.0, 1.0)
                .set_brightness((float)id(light_brightness)/255.0)
                .perform();
          } else if (id(light_mode) == 3) {
              auto effects = id(backlight).get_effects();
              int idx = id(light_effect_id);  // your global integer
              if (idx >= 0 && idx < effects.size()) {
                  id(backlight).turn_on()
                      .set_effect(idx)
                      .set_rgb((float)id(light_color_red)/255.0,
                              (float)id(light_color_green)/255.0,
                              (float)id(light_color_blue)/255.0)
                      .set_brightness((float)id(light_brightness)/255.0)
                      .perform();
              } else {
                  ESP_LOGW("light", "Invalid effect_id: %d", idx);
              }
          }
          id(update_ble_characteristics).execute();

  - id: update_ble_characteristics
    then:
      - lambda: |-
          // Light mode
          id(light_mode_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_mode)});
          id(light_mode_char).notify();

          // Brightness
          id(light_brightness_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_brightness)});
          id(light_brightness_char).notify();

          // Color
          id(light_color_char).set_value(std::vector<uint8_t>{
            (uint8_t)id(light_color_red),
            (uint8_t)id(light_color_green),
            (uint8_t)id(light_color_blue)
          });
          id(light_color_char).notify();

          // Current Effect
          id(light_current_effect_char).set_value(std::vector<uint8_t>{(uint8_t)id(light_effect_id)});
          id(light_current_effect_char).notify();

          // Shake detection toggle
          id(shake_enable_char).set_value(std::vector<uint8_t>{ (uint8_t)(id(shake_enabled) ? 1 : 0) });
          id(shake_enable_char).notify();

          // Overheat protection toggle
          id(overheat_enable_char).set_value(std::vector<uint8_t>{ (uint8_t)(id(overheat_protection_enabled) ? 1 : 0) });
          id(overheat_enable_char).notify();

esp32_ble_server:
  manufacturer: "CycloPi"
  model: "Omnilight"
  on_connect:
    then:
      - delay: 2s
      - script.execute: update_ble_characteristics
      - delay: 2s
      - script.execute: update_ble_characteristics
      - delay: 2s
      - script.execute: update_ble_characteristics
  services:
    - uuid: "12345678-1234-5678-1234-56789abcdef0"
      advertise: true
      characteristics:

        # Save Preferences Trigger
        - id: save_prefs_char
          uuid: "abcdef00-1234-5678-1234-56789abcdef0"
          description: "Save preferences (write any value to persist settings)"
          read: false
          write: true
          notify: true
          value:
            type: uint8_t
            data: 0
          descriptors:
            - uuid: 2901
              value: "Write any value to save current preferences"
          on_write:
            then:
              - lambda: |-
                  ESP_LOGI("ble", "Save preferences characteristic written, persisting globals...");
                  // Manually flush pending preference writes to flash
                  bool ok = global_preferences->sync();
                  if (ok) {
                    ESP_LOGI("ble", "Preferences saved successfully.");
                    // Optional ACK: 1 = success
                    id(save_prefs_char).set_value(std::vector<uint8_t>{1});
                    id(save_prefs_char).notify();
                  } else {
                    ESP_LOGW("ble", "Preferences save failed.");
                    // Optional NACK: 0 = failure
                    id(save_prefs_char).set_value(std::vector<uint8_t>{0});
                    id(save_prefs_char).notify();
                  }

        # Light mode characteristic
        - id: light_mode_char
          uuid: "abcdef01-1234-5678-1234-56789abcdef0"
          description: "Light Mode: 0=Off,1=Solid,2=Effect"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 0
          descriptors:
            - uuid: 2901
              value: "Set light mode: 0=Off,1=Solid,2=Effect"
          on_write:
            then:
              - lambda: |-
                  uint8_t mode = x[0];
                  ESP_LOGD("ble", "Light mode written: %d", mode);
                  id(light_mode) = mode;
              - script.execute: apply_light_state

        # Brightness characteristic
        - id: light_brightness_char
          uuid: "abcdef02-1234-5678-1234-56789abcdef0"
          description: "Brightness (0-255)"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 255
          descriptors:
            - uuid: 2901
              value: "Set brightness 0-255"
          on_write:
            then:
              - lambda: |-
                  uint8_t b = x[0];
                  id(light_brightness) = b;
                  ESP_LOGD("ble", "Brightness written: %d", id(light_brightness));
              - script.execute: apply_light_state

        # Color characteristic (RGB)
        - id: light_color_char
          uuid: "abcdef03-1234-5678-1234-56789abcdef0"
          description: "Effect Color RGB"
          read: true
          write: true
          notify: true
          value: "0xFF0000"  # red as default
          descriptors:
            - uuid: 2901
              value: "Set color: RGB bytes 0-255"
          on_write:
            then:
              - lambda: |-
                  uint8_t r = x[0];
                  uint8_t g = x[1];
                  uint8_t b = x[2];
                  id(light_color_red)   = r;
                  id(light_color_green) = g;
                  id(light_color_blue)  = b;
                  ESP_LOGD("ble", "Color written: R=%d G=%d B=%d", r, g, b);
              - script.execute: apply_light_state

        # Current Effect Name
        - id: light_current_effect_char
          uuid: "abcdef06-1234-5678-1234-56789abcdef0"
          description: "Current Light Effect Name"
          read: true
          write: true
          notify: true
          value: !lambda |-
            return std::vector<uint8_t>{(uint8_t)id(light_effect_id)};
          on_write:
            then:
              - lambda: |-
                  if (!x.empty()) {
                    id(light_effect_id) = x[0];
                    ESP_LOGD("ble", "Effect ID written: %d", id(light_effect_id));
                  }
              - script.execute: apply_light_state
          descriptors:
            - uuid: 2901
              value: "Current light effect"

        # Shake Detection Toggle
        - id: shake_enable_char
          uuid: "abcdef04-1234-5678-1234-56789abcdef0"
          description: "Enable/Disable Shake Detection (0=Off, 1=On)"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 1   # default enabled
          descriptors:
            - uuid: 2901
              value: "Toggle shake detection"
          on_write:
            then:
              - lambda: |-
                  bool enabled = x[0] != 0;
                  id(shake_enabled) = enabled;
                  ESP_LOGD("ble", "Shake detection written: %s", enabled ? "enabled" : "disabled");

        # Overheat Protection Toggle
        - id: overheat_enable_char
          uuid: "abcdef05-1234-5678-1234-56789abcdef0"
          description: "Enable/Disable Overheat Protection (0=Off, 1=On)"
          read: true
          write: true
          notify: true
          value:
            type: uint8_t
            data: 1   # default enabled
          descriptors:
            - uuid: 2901
              value: "Toggle overheat protection"
          on_write:
            then:
              - lambda: |-
                  bool enabled = x[0] != 0;
                  id(overheat_protection_enabled) = enabled;
                  ESP_LOGD("ble", "Overheat protection written: %s", enabled ? "enabled" : "disabled");

        # Estimated Power
        - uuid: "abcdef20-1234-5678-1234-56789abcdef0"
          description: "Estimated Power"
          id: estimated_power_char
          notify: true

        # Acceleration XYZ (3x float32 = 12 bytes)
        - id: accel_char
          uuid: "abcdef10-1234-5678-1234-56789abcdef0"
          description: "Acceleration X,Y,Z in m/s²"
          read: true
          notify: true

        # Gyroscope XYZ (3x float32 = 12 bytes)
        - id: gyro_char
          uuid: "abcdef11-1234-5678-1234-56789abcdef0"
          description: "Gyroscope X,Y,Z in °/s"
          read: true
          notify: true

        # IMU Temperature (float32 = 4 bytes)
        - id: temp_char
          uuid: "abcdef12-1234-5678-1234-56789abcdef0"
          description: "IMU Temperature in °C"
          read: true
          notify: true

interval:
  - interval: 1s
    then:
      # Update accel values (3 floats)
      - lambda: |-
          float ax = id(accel_x).state;
          float ay = id(accel_y).state;
          float az = id(accel_z).state;
          std::vector<uint8_t> accel_bytes(reinterpret_cast<uint8_t*>(&ax), reinterpret_cast<uint8_t*>(&ax) + sizeof(float));
          accel_bytes.insert(accel_bytes.end(), reinterpret_cast<uint8_t*>(&ay), reinterpret_cast<uint8_t*>(&ay) + sizeof(float));
          accel_bytes.insert(accel_bytes.end(), reinterpret_cast<uint8_t*>(&az), reinterpret_cast<uint8_t*>(&az) + sizeof(float));
          id(accel_char).set_value(accel_bytes);
          id(accel_char).notify();
      # Update gyro values (3 floats)
      - lambda: |-
          float gx = id(gyro_x).state;
          float gy = id(gyro_y).state;
          float gz = id(gyro_z).state;
          std::vector<uint8_t> gyro_bytes(reinterpret_cast<uint8_t*>(&gx), reinterpret_cast<uint8_t*>(&gx) + sizeof(float));
          gyro_bytes.insert(gyro_bytes.end(), reinterpret_cast<uint8_t*>(&gy), reinterpret_cast<uint8_t*>(&gy) + sizeof(float));
          gyro_bytes.insert(gyro_bytes.end(), reinterpret_cast<uint8_t*>(&gz), reinterpret_cast<uint8_t*>(&gz) + sizeof(float));
          id(gyro_char).set_value(gyro_bytes);
          id(gyro_char).notify();
      # Update temperature value (1 float)
      - lambda: |-
          float t = id(imu_temp).state;
          std::vector<uint8_t> temp_bytes(reinterpret_cast<uint8_t*>(&t), reinterpret_cast<uint8_t*>(&t) + sizeof(float));
          id(temp_char).set_value(temp_bytes);
          id(temp_char).notify();

  # Shake detection
  - interval: 50ms
    then:
      - lambda: |-
          if (!id(shake_enabled)) return;  // shake disabled

          static unsigned long last_trigger = 0;
          unsigned long now = millis();

          float ax = id(accel_x).state;
          float ay = id(accel_y).state;
          float az = id(accel_z).state;
          float magnitude = sqrt(ax*ax + ay*ay + az*az);

          const float threshold = 6;  // m/s²
          const unsigned long debounce = 500; // ms

          if (magnitude > threshold && now - last_trigger > debounce) {
            last_trigger = now;

            // increment light mode modulo 4 light modes
            id(light_mode) = (id(light_mode) + 1) % 4;

            ESP_LOGD("shake", "Shake detected, new light mode: %d", id(light_mode));

            // apply new light state via script
            id(apply_light_state).execute();
          }

  # Avoid overheating, reduce brightness
  - interval: 1s
    then:
      - lambda: |-
          if (!id(overheat_protection_enabled)) return;  // disabled

          static float last_temp = 0.0f;
          static uint32_t last_reduction_time = 0;
          static bool first_overheat = true;

          float temp = id(imu_temp).state;
          uint32_t now = millis();

          if (temp > 68.0f) {
            // On first entry above threshold, wait at least 10s
            if (first_overheat) {
              if ((now - last_reduction_time) < 10000) {
                last_temp = temp;
                return;
              }
              first_overheat = false;
            }

            // Compute temperature change since last action
            float delta = max(0.0f, temp - last_temp);
            float elapsed = (now - last_reduction_time) / 1000.0f; // seconds since last action
            if (elapsed <= 0) elapsed = 1.0f;

            // Larger delta => shorter wait, smaller delta => longer wait
            uint32_t wait_time = (uint32_t)(30000.0f - (delta * 5000.0f));
            if (wait_time < 5000) wait_time = 5000;    // clamp min
            if (wait_time > 30000) wait_time = 30000;  // clamp max

            if ((now - last_reduction_time) > wait_time || delta > 0.5f) {
              int current_brightness = id(light_brightness);

              // Reduction based on absolute temp
              float diff = temp - 68.0f;
              float factor = expf(diff / 5.0f);
              float reduction = 5.0f * (factor - 1.0f);

              // Extra scaling by heating rate (delta / elapsed)
              float rate = delta / elapsed;  // °C per second
              if (rate > 0) reduction *= (1.0f + rate * 2.0f);  // amplify with slope

              reduction = min(30.0f, reduction);  // Clamp
              int new_brightness = max(32, current_brightness - static_cast<int>(reduction));
              ESP_LOGD("brightness",
                      "New brightness due to over temp (%d -> %d, %.1f°C, ΔT=%.2f over %.1fs, rate=%.3f°C/s, wait=%ums)",
                      current_brightness, new_brightness, temp, delta, elapsed, rate, wait_time);

              id(light_brightness) = new_brightness;
              id(apply_light_state).execute();
              last_reduction_time = now;
              last_temp = temp;
            }
          } else {
            first_overheat = true;  // Reset state once cooled
            last_temp = temp;
            last_reduction_time = now;
          }

light:
  - platform: esp32_rmt_led_strip
    rgb_order: RGB
    chipset: ws2811
    id: backlight
    pin: GPIO14
    num_leds: 64
    default_transition_length: 0.3s
    color_correct: [100%, 70%, 100%]
    effects:
      - flicker:
          name: "Flicker"
          intensity: 1%
          alpha: 99%
      - addressable_rainbow:
          name: "Rainbow"
      - addressable_fireworks:
          name: "Fireworks"
      - pulse:
          name: "Pulse"
      - strobe:
          name: 'Backlight'
          colors:
            - state: true
              red: 100%
              green: 0%
              blue: 0%
              duration: 300ms
            - state: true
              red: 100%
              green: 75%
              blue: 0%
              duration: 50ms
            - state: false
              duration: 150ms

i2c:
  sda: GPIO11
  scl: GPIO12

sensor:
  - platform: qmi8658
    address: 0x6B
    interrupt_pin_2: GPIO13
    acceleration_x:
      id: accel_x
      name: "QMI8658 Acceleration X"
    acceleration_y:
      id: accel_y
      name: "QMI8658 Acceleration Y"
    acceleration_z:
      id: accel_z
      name: "QMI8658 Acceleration Z"
    gyroscope_x:
      id: gyro_x
      name: "QMI8658 Gyro X"
    gyroscope_y:
      id: gyro_y
      name: "QMI8658 Gyro Y"
    gyroscope_z:
      id: gyro_z
      name: "QMI8658 Gyro Z"
    temperature:
      id: imu_temp
      name: "QMI8658 Temperature"
      filters:
        - offset: 1.0
        - multiply: 0.75
    update_interval: 1s

  - platform: template
    id: estimated_power_w
    name: "Estimated Power"
    unit_of_measurement: "W"
    accuracy_decimals: 1
    update_interval: 1s
    on_value:
      then:
        - lambda: |-
            float p = id(estimated_power_w).state;
            std::vector<uint8_t> power_bytes(reinterpret_cast<uint8_t*>(&p), reinterpret_cast<uint8_t*>(&p) + sizeof(float));
            id(estimated_power_char).set_value(power_bytes);
            id(estimated_power_char).notify();
    lambda: |-
      const float V = 5.0;               // LED supply voltage
      const int   N = 64;                // number of LEDs
      const float per_led_full = 0.015f; // 15 mA at full white (A)
      // Fraction of full RGB power based on current color & brightness
      const float rgb_frac = ( (id(light_color_red) + id(light_color_green) + id(light_color_blue)) / (3.0f * 255.0f) );
      const float brt_frac = id(light_brightness) / 255.0f;
      float led_I = 0.0f;

      switch (id(light_mode)) {
        case 0: // Off
          led_I = 0.0f;
          break;
        case 1: // Backlight
          led_I = 0.4f;  // Experimental measurement
          break;
        case 3: // Effect
          led_I = N * per_led_full * rgb_frac * brt_frac;
          break;
        case 2: // Frontlight
        default:
          led_I = N * per_led_full * brt_frac;
      }

      // ESP32 baseline (tune!): ~80 mA when active with Wi-Fi/BLE
      const float esp_I = 0.100f;

      float watts = V * (led_I + esp_I);
      return watts;
